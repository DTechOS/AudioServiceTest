#include <windows.h>
#include <audioclient.h>
#include <Mmdeviceapi.h>
#include <iostream>
#include <string>
#include <ctime>
#include <assert.h>

// write capture to new file on each run
//#define AUDIO_CAPTURE_FILE		L"Capture.wav"
#define REFTIMES_PER_SEC		30000000
#define REFTIMES_PER_MILLISEC	30000
#define MAX_LOOP_BEFORE_STOP	20

const CLSID CLSID_MMDeviceEnumerator = __uuidof(MMDeviceEnumerator);
const IID IID_IMMDeviceEnumerator = __uuidof(IMMDeviceEnumerator);
const IID IID_IAudioClient = __uuidof(IAudioClient);
const IID IID_IAudioCaptureClient = __uuidof(IAudioCaptureClient);

// MAIN BEGIN
HRESULT RecordAudioStream();

void main()
{
	HRESULT hr = CoInitializeEx(NULL, COINIT_APARTMENTTHREADED | COINIT_DISABLE_OLE1DDE);
	if (SUCCEEDED(hr))
	{
		while (true)
		{
			RecordAudioStream();

			Sleep(30000);

		}
		CoUninitialize();
	}
}

// MAIN END

/*
------------------------------|
WAVEWRITER CLASS BEGIN        |
------------------------------|
*/

const UINT32 WAVE_HEAD_LEN = 44;
const UINT32 WAVE_HEAD_EXT_LEN = 80;

#define SWAP32(val) (UINT32)((((UINT32)(val)) & 0x000000FF)<<24 | (((UINT32)(val)) & 0x0000FF00)<<8 | (((UINT32)(val)) & 0x00FF0000)>>8 | (((UINT32)(val)) & 0xFF000000)>>24)

struct RIFFCHUNK
{
	UINT32 fcc;
	UINT32 cb;
};

struct RIFFLIST
{
	UINT32 fcc;
	UINT32 cb;
	UINT32 fccListType;

};

struct WAVEFORM
{
	UINT32 fcc;
	UINT32 cb;
	UINT16 wFormatTag;
	UINT16 nChannels;
	UINT32 nSamplesPerSec;
	UINT32 nAvgBytesPerSec;
	UINT16 nBlockAlign;
	UINT16 wBitsPerSample;
};

struct WAVEFORM_EXT : public WAVEFORM
{
	UINT16 cbSize;
	UINT16 wValidBitsPerSample;
	UINT32 dwChannelMask;
	GUID SubFormat;
};

struct FACT
{
	UINT32 fcc;
	UINT32 cb;
	UINT32 lenght;

};

#pragma pack(pop)

class CMFWaveWriter
{
public:

	CMFWaveWriter() : m_hFile(INVALID_HANDLE_VALUE) {}
	//~CMFWaveWriter() { CLOSE_HANDLE_IF(m_hFile); }

	BOOL Initialize(const WCHAR*, const BOOL);
	BOOL WriteWaveData(const BYTE*, const DWORD);
	BOOL FinalizeHeader(WAVEFORMATEX*, const UINT32, const BOOL);

private:

	HANDLE m_hFile;

	BOOL SetWaveHeader(const WAVEFORMATEX*, const UINT32, BYTE*);
	BOOL SetWaveHeaderExt(WAVEFORMATEX*, const UINT32, BYTE*);
};

/*
------------------------------
WAVEWRITER CLASS END
------------------------------
*/


// WAVEWRITER FUNCTIONS BEGIN

BOOL CMFWaveWriter::Initialize(const WCHAR* wszFile, const BOOL bExtensibleFormat)
{

	BOOL bRet = FALSE;
	const UINT32 bHeaderLenght = bExtensibleFormat ? WAVE_HEAD_EXT_LEN : WAVE_HEAD_LEN;

	m_hFile = CreateFile(wszFile, GENERIC_WRITE, FILE_SHARE_READ, NULL, CREATE_NEW, FILE_ATTRIBUTE_NORMAL, 0);
	if (m_hFile == INVALID_HANDLE_VALUE) { return bRet; }

	BYTE WavHeader[WAVE_HEAD_EXT_LEN];
	memset(WavHeader, 0, sizeof(WavHeader));

	DWORD dwWritten;

	if (!WriteFile(m_hFile, (LPCVOID)WavHeader, bHeaderLenght, &dwWritten, 0) || dwWritten != bHeaderLenght)
	{
		std::cout << "unable to initialize write file"; return 1;
	}

	return bRet = TRUE;
}


BOOL CMFWaveWriter::WriteWaveData(const BYTE* pData, const DWORD dwLength)
{
	BOOL bRet = FALSE;
	DWORD dwWritten;

	if (!WriteFile(m_hFile, (LPCVOID)pData, dwLength, &dwWritten, 0) || dwWritten != dwLength)
	{
		std::cout << "error in WriteWaveData"; return 1;
	}

	return bRet = TRUE;
}


BOOL CMFWaveWriter::FinalizeHeader(WAVEFORMATEX* pwfx, const UINT32 uiFileLength, const BOOL bExtensibleFormat)
{
	BOOL bRet = FALSE;
	DWORD dwMove;
	DWORD dwWritten;
	const UINT32 bHeaderLenght = bExtensibleFormat ? WAVE_HEAD_EXT_LEN : WAVE_HEAD_LEN;

	BYTE WavHeader[WAVE_HEAD_EXT_LEN];
	memset(WavHeader, 0, sizeof(WavHeader));

	if ((dwMove = SetFilePointer(m_hFile, 0, NULL, FILE_BEGIN)) == INVALID_SET_FILE_POINTER)
	{
		{std::cout << "Error setting file pointer "; return 1; }
	}

	if (bExtensibleFormat)
	{
		if (!SetWaveHeaderExt(pwfx, uiFileLength, WavHeader))
		{
			{std::cout << "error setting extensible format "; return 1; }
		}
	}
	else
	{
		if (!SetWaveHeader(pwfx, uiFileLength, WavHeader))
		{
			{std::cout << "error setting extensible format"; return 1; }
		}
	}

	if (!WriteFile(m_hFile, (LPCVOID)WavHeader, bHeaderLenght, &dwWritten, 0) || dwWritten != bHeaderLenght)
	{
		{std::cout << "error setting extensible format"; return 1; }
	}

	return bRet = TRUE;
}


BOOL CMFWaveWriter::SetWaveHeaderExt(WAVEFORMATEX* pwfx, const UINT32 uiDataLen, BYTE* head)
{
	if (uiDataLen == 0)
		return FALSE;

	assert((uiDataLen * pwfx->nBlockAlign) % 2 == 0);

	RIFFCHUNK* pch;
	RIFFLIST* priff;
	WAVEFORM_EXT* pwaveExt;
	FACT* pFact;
	WAVEFORMATEXTENSIBLE* pWaveFormatExtensible = reinterpret_cast<WAVEFORMATEXTENSIBLE*>(pwfx);

	priff = (RIFFLIST*)head;
	priff->fcc = SWAP32('RIFF');
	priff->cb = (uiDataLen * pwfx->nBlockAlign) + WAVE_HEAD_EXT_LEN - sizeof(RIFFCHUNK);
	priff->fccListType = SWAP32('WAVE');

	pwaveExt = (WAVEFORM_EXT*)(priff + 1);
	pwaveExt->fcc = SWAP32('fmt ');
	pwaveExt->cb = sizeof(WAVEFORM_EXT) - sizeof(RIFFCHUNK);
	pwaveExt->wFormatTag = pwfx->wFormatTag;
	pwaveExt->nChannels = pwfx->nChannels;
	pwaveExt->nSamplesPerSec = pwfx->nSamplesPerSec;
	pwaveExt->nAvgBytesPerSec = pwfx->nAvgBytesPerSec;
	pwaveExt->nBlockAlign = pwfx->nBlockAlign;
	pwaveExt->wBitsPerSample = pwfx->wBitsPerSample;
	pwaveExt->cbSize = pwfx->cbSize;
	pwaveExt->wValidBitsPerSample = pWaveFormatExtensible->Samples.wValidBitsPerSample;
	pwaveExt->dwChannelMask = pWaveFormatExtensible->dwChannelMask;
	pwaveExt->SubFormat = pWaveFormatExtensible->SubFormat;

	pFact = (FACT*)(pwaveExt + 1);
	pFact->fcc = SWAP32('fact');
	pFact->cb = 4;
	pFact->lenght = uiDataLen * pwaveExt->nChannels;

	pch = (RIFFCHUNK*)(pFact + 1);
	pch->fcc = SWAP32('data');
	pch->cb = (uiDataLen * pwfx->nBlockAlign);

	return TRUE;
} 

BOOL CMFWaveWriter::SetWaveHeader(const WAVEFORMATEX* pwfx, const UINT32 uiDataLen, BYTE* head)
{
	if (uiDataLen == 0)
		return FALSE;

	RIFFCHUNK* pch;
	RIFFLIST* priff;
	WAVEFORM* pwave;

	priff = (RIFFLIST*)head;
	priff->fcc = SWAP32('RIFF');

	priff->cb = (uiDataLen * pwfx->nBlockAlign) + WAVE_HEAD_LEN - sizeof(RIFFCHUNK);
	priff->fccListType = SWAP32('WAVE');

	pwave = (WAVEFORM*)(priff + 1);
	pwave->fcc = SWAP32('fmt ');
	pwave->cb = sizeof(WAVEFORM) - sizeof(RIFFCHUNK);
	pwave->wFormatTag = pwfx->wFormatTag;
	pwave->nChannels = pwfx->nChannels;
	pwave->nSamplesPerSec = pwfx->nSamplesPerSec;
	pwave->nAvgBytesPerSec = pwfx->nAvgBytesPerSec;
	pwave->nBlockAlign = pwfx->nBlockAlign;
	pwave->wBitsPerSample = pwfx->wBitsPerSample;

	pch = (RIFFCHUNK*)(pwave + 1);
	pch->fcc = SWAP32('data');
	pch->cb = (uiDataLen * pwfx->nBlockAlign);

	return TRUE;
}
// WAVEWRITER FUNCTIONS END

// RECORD AUDIO FUNC BEGIN

HRESULT RecordAudioStream()
{
		HRESULT hr = S_OK;
		IMMDeviceEnumerator* pEnumerator = NULL;
		IMMDevice* pDevice = NULL;
		IAudioClient* pAudioClient = NULL;
		IAudioCaptureClient* pCaptureClient = NULL;
		WAVEFORMATEX* pwfx = NULL;
		REFERENCE_TIME hnsRequestedDuration = REFTIMES_PER_SEC;
		REFERENCE_TIME hnsActualDuration;
		UINT32 bufferFrameCount;
		CMFWaveWriter cMFWaveWriter;
		UINT32 uiFileLength = 0;
		BOOL bExtensibleFormat = FALSE;

	try
	{
		hr = CoCreateInstance(CLSID_MMDeviceEnumerator, NULL, CLSCTX_ALL, IID_IMMDeviceEnumerator, (void**)&pEnumerator);
		hr = pEnumerator->GetDefaultAudioEndpoint(eCapture, eConsole, &pDevice);
		hr = pDevice->Activate(IID_IAudioClient, CLSCTX_ALL, NULL, (void**)&pAudioClient);

		hr = pAudioClient->GetMixFormat(&pwfx);

		switch (pwfx->wFormatTag)
		{
		case WAVE_FORMAT_PCM:
			std::cout << "WAVE_FORMAT_PCM\n";
			break;

		case WAVE_FORMAT_IEEE_FLOAT:
			std::cout << "WAVE_FORMAT_IEEE_FLOAT\n";
			break;

		case WAVE_FORMAT_EXTENSIBLE:
			std::cout << "WAVE_FORMAT_EXTENSIBLE\n";
			bExtensibleFormat = TRUE;

			WAVEFORMATEXTENSIBLE* pWaveFormatExtensible = reinterpret_cast<WAVEFORMATEXTENSIBLE*>(pwfx);

			if (pWaveFormatExtensible->SubFormat == KSDATAFORMAT_SUBTYPE_PCM)
			{
				std::cout << "KSDATAFORMAT_SUBTYPE_PCM\n";
			}
			else if (pWaveFormatExtensible->SubFormat == KSDATAFORMAT_SUBTYPE_IEEE_FLOAT)
			{
				std::cout << "KSDATAFORMAT_SUBTYPE_IEEE_FLOAT\n";
			}
			break;
		}

		// Get the current timestamp as a string
		time_t now = time(nullptr);
		struct tm timeInfo;
		localtime_s(&timeInfo, &now);
		char buffer[80];
		strftime(buffer, sizeof(buffer), "%Y%m%d_%H%M%S", &timeInfo);
		std::string timestamp = buffer;
		int iLoop = 0;

		// Construct the filename using the timestamp
		std::string filename = "output_" + timestamp + ".wav";

		// Convert the filename to a wchar_t* for CreateFileW
		wchar_t wFilename[MAX_PATH];
		MultiByteToWideChar(CP_UTF8, 0, filename.c_str(), -1, wFilename, MAX_PATH);

		hr = pAudioClient->Initialize(AUDCLNT_SHAREMODE_SHARED, 0, hnsRequestedDuration, 0, pwfx, NULL);
		hr = pAudioClient->GetBufferSize(&bufferFrameCount);
		hr = pAudioClient->GetService(IID_IAudioCaptureClient, (void**)&pCaptureClient);

		hr = cMFWaveWriter.Initialize(wFilename, bExtensibleFormat) ? S_OK : E_FAIL;

		hnsActualDuration = (double)REFTIMES_PER_SEC * bufferFrameCount / pwfx->nSamplesPerSec;

		hr = pAudioClient->Start();

		BOOL bDone = FALSE;
		UINT32 packetLength = 0;
		UINT32 numFramesAvailable;
		BYTE* pData;
		DWORD flags;


		while (bDone == false)
		{
			Sleep(hnsActualDuration / REFTIMES_PER_MILLISEC / 2);

			hr = pCaptureClient->GetNextPacketSize(&packetLength);

			while (packetLength != 0)
			{
				hr = pCaptureClient->GetBuffer(&pData, &numFramesAvailable, &flags, NULL, NULL);

				if (flags & AUDCLNT_BUFFERFLAGS_SILENT)
				{
					std::cout << " AUDCLNT_BUFFERFLAGS_SILENT \n";
					break;
				}

				if (flags & AUDCLNT_BUFFERFLAGS_DATA_DISCONTINUITY)
				{
					std::cout << " AUDCLNT_BUFFERFLAGS_DATA_DISCONTINUITY \n";
				}

				if (flags & AUDCLNT_BUFFERFLAGS_TIMESTAMP_ERROR)
				{
					std::cout << " AUDCLNT_BUFFERFLAGS_TIMESTAMP_ERROR \n";
				}

				//TRACE((L"numFramesAvailable : %u", numFramesAvailable));

				assert(packetLength == numFramesAvailable);

				hr = cMFWaveWriter.WriteWaveData(pData, numFramesAvailable * pwfx->nBlockAlign) ? S_OK : E_FAIL;

				uiFileLength += numFramesAvailable;

				hr = pCaptureClient->ReleaseBuffer(numFramesAvailable);

				hr = pCaptureClient->GetNextPacketSize(&packetLength);
			}
			if (iLoop++ == MAX_LOOP_BEFORE_STOP)
				bDone = TRUE;
		}
	}
	catch (HRESULT) {}

	std::cout << "\nuiFileLength : %u" << uiFileLength;

	if (hr == S_OK && pwfx != NULL)
		cMFWaveWriter.FinalizeHeader(pwfx, uiFileLength, bExtensibleFormat);

	if (pAudioClient)
	{
		hr = pAudioClient->Stop();
		//SAFE_RELEASE(pAudioClient);
		hr = pAudioClient->Release();
	}

	CoTaskMemFree(pwfx);
	hr = pCaptureClient->Release();
	hr = pEnumerator->Release();
	hr = pDevice->Release();

	return hr;
}